# -*- coding: utf-8 -*-
"""Exercise Sheet 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MnspGdFTfZzr_-ARdj7mFC1hAOJyRexS
"""

import numpy as np
from copy import deepcopy

"""**The Sphere Function:**
The following is a sphere function which has a ***minimum*** value of 0 when passed  a vector containing all 0s.    We use this as a "toy" problem to show if the algorithm is working properly, i.e. the algorithm should "find" or "approximate" the solution with all 0's
"""

def sphere_function(x):
  return sum(x**2)

"""**Exercise**  Adjust the function above to look for the solution (1,2,3,4,5)

*Hint:    If x = 3 then (x-3) = 0*

**Exercise** Adjust the function above to look for the solution (1,2,4,8,...,2^m)  where m could be any integer greater than 2

*Hint: If x = 3 then (x-3) = 0 and you may need to use a for loop*
"""

def sumPows2(v):
  targetValue = 1
  sum = 0
  for x in v:
    sum += (x - targetValue)**2
    targetValue *=2
  return sum

"""**Exercise**   Write a cost function which would solve the following linear inequality problem

Minimise the following function $3x+4y+5z$ subject to the following conditions..
$x\ge0 , y\ge0 , z\ge0$

$x+y+z >10$         
$2y+4z > 25$

"""

class problem:
  def __init__(self):
    self.number_of_genes = 8
    self.min_gene_value = -10
    self.max_gene_value = 10
    self.cost_function = sphere_function

def costLP(v):
  if v[0] + v[1] + v[2] <10:  #x+y+z <10
    return 10000000
  if 2*v[1] +4*v[2] <25:  # 2y+4z<25
    return 10000000
  return 3*v[0] +4*v[1]+5*v[2]  #3x+4y+5z

costLP([8,2,7])

"""**Exercise** If you wanted to find the solution which ***maximised*** a given function e.g. $f(x,y,z) = 5-2x^2 -7y^4 - 10 z^6$  how could you construct the cost function here.

---


**The Problem Definition**

The following Class defines the problem, this will change accoring to the problem you are looking to solve.
"""

class problemLP:
  def __init__(self):
    self.number_of_genes = 3 # x,y,z
    self.min_gene_value = 0
    self.max_gene_value = 10
    self.cost_function = costLP



"""---
**Exercise**  Re-write the above problem for each of the exercises above.

"""

p = problemLP()

class individual:
  # This class defines the individual for the genetic algorithm. We hope to find the individual which solves our problem
  chromosone = None

  def __init__(self, prob):    #  This is the constructor for the individual and as such needs the problem to mould the individuals to it
    #Create a random individual.
    self.chromosone = np.random.uniform(prob.min_gene_value,prob.max_gene_value,prob.number_of_genes)
    self.cost = prob.cost_function(self.chromosone)

class parameters:
  def __init__(self):
    self.number_in_population = 1000
    self.number_of_generations = 500
    self.child_rate = 0.5

"""**Exercise**   Write a for loop that creates a parameters instance with populations ranging from 100 to 1000 in steps of 100

**Exercise**    Write nested for loops to cover all possible parameter setups with

$100 \le$ number_in_population $\le 1000$ in steps of 100

$100 \le$ number_of_generations $\le 500$ in steps of 50

$0.1 \le$ child_rate $\le 1$ in steps of 0.1

---
**Executing the Genetic Algorithm**

The following method executes the genetic algorithm, for the problem passed in as prob, and with the parameters passed in as params. This will...



*   Read in the problem and the parameters for the algorithm
*   Initialise the population


> *   Create the required amount of appropriately randomly generated individuals
*   Keep track of the "Best individual/ best cost"

The algorithm runs over many generations (max number usually specified in parameters)

Repeat following until max number of generations reached or solution found
  

---


  >Generate this generation of children


*   Select Parents
*   Crossover Parents -> Children
*   Mutate


Add Children to population

Sort and Cull population
*   Update best solution if better found
---

Usuall return the Best Solution/ Cost as the solution to the problem
"""

def run_genetic(prob, params):
  #  read the problem
  cost_function = prob.cost_function

  #   read parameters
  number_in_population = params.number_in_population
  number_of_children = params.child_rate * number_in_population

  #  Initialise the population
  best_solution = individual(prob)
  best_solution.cost = 999999

  population = []
  for i in range(number_in_population):
    new_individual = individual(prob)
    population.append(new_individual)
    if new_individual.cost < best_solution.cost:
      best_solution = deepcopy(new_individual)  # copy new_individual


# loop

  #generate children
  children = []
  while len(children) < number_of_children:


    # choose parents
    parent1_index, parent2_index = choose_different_indices(len(population))
    parent1 = population[parent1_index]
    parent2 = population[parent2_index]




    #  cost the children


  # add children to popuation

  # sort and cull population



  return population, best_solution

prob = problemLP()
param = parameters()



def choose_different_indices(max_value):
  index1 = np.random.randint(0,max_value)
  index2 = np.random.randint(0,max_value)
  if index1 == index2:
    return choose_different_indices(max_value)
  return index1, index2

solution = run_genetic(prob,param)

