# -*- coding: utf-8 -*-
"""Genetic 24.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UG2VZ08yM7srhN8Hha3hXAfInn5D6byg
"""

import numpy as np
from copy import deepcopy

"""# The cost function

Here we will be using a ***toy*** cost function which has a minimum of 0, and the only solution which has this cost consists of all 0 entries
"""

def sphere(x):
  total = 0
  for i in x:
    total+= i**2

  return total

"""# The Problem
We abstract the problem into a class

Key to this is the cost function, the solution is the set of values (of the chromosome of an individual) which minimise this function.

These values are broadly defined here in the problem.
"""

class problem:
  def __init__(self):
    self.number_of_genes = 8
    self.max_value = 10
    self.min_value = -10
    self.cost_function = sphere

"""# The individual

This abstracted into a class, which will be determined by the problem.
The main components of this are


*   Generate a random individual
*   Mutate
*   Crossover

These will typically have to be adjusted for differing problems


"""

class individual:
  def __init__(self,prob):
    self.chromosome = np.random.uniform(prob.min_value, prob.max_value,prob.number_of_genes)
    self.cost = prob.cost_function(self.chromosome)

  def mutate(self, rate_of_gene_mutation,range_of_gene_mutation):
    for index in range(len(self.chromosome)):
      if  np.random.uniform() < rate_of_gene_mutation:
        self.chromosome[index] += np.random.randn() * range_of_gene_mutation

  def crossover(self,parent2,explore_crossover):
    alpha = np.random.uniform(-explore_crossover, 1+explore_crossover)
    child1 = deepcopy(self)
    child2 = deepcopy(parent2)
    child1.chromosome = alpha * self.chromosome + (1-alpha)*parent2.chromosome
    child2.chromosome = alpha * parent2.chromosome + (1-alpha)*self.chromosome
    return child1,child2

p1=problem()
par1 = parameters()

class parameters:
  def __init__(self):
    self.population  = 1000
    self.number_of_generations = 100
    self.child_rate_per_generation = 1
    self.crossover_explore_rate = 0.2
    self.gene_mutate_range = 0.5
    self.gene_mutate_rate = 0.2



def choose_indices_from(number_in_list):
  index_1 = np.random.randint(number_in_list)
  index_2 = np.random.randint(number_in_list)
  if index_1 == index_2:
    return choose_indices_from(number_in_list)
  return index_1,index_2

"""

---
**Executing the Genetic Algorithm**

The following method executes the genetic algorithm, for the problem passed in as prob, and with the parameters passed in as params. This will...



*   Read in the problem and the parameters for the algorithm
*   Initialise the population


> *   Create the required amount of appropriately randomly generated individuals
*   Keep track of the "Best individual/ best cost"

The algorithm runs over many generations (max number usually specified in parameters)

Repeat following until max number of generations reached or solution found
  

---


  >Generate this generation of children


*   Select Parents
*   Crossover Parents -> Children
*   Mutate


Add Children to population

Sort and Cull population
*   Update best solution if better found
---

Usually returns the Best Solution/ Cost as the solution to the problem


"""

def run_genetic(prob, params):
  # Read in important info from problem
  cost_function = prob.cost_function


  number_in_population = params.population
  max_number_of_generations = params.number_of_generations
  number_of_children_per_generation = params.child_rate_per_generation * number_in_population
  explore_crossover = params.crossover_explore_rate
  gene_mutate_rate = params.gene_mutate_rate
  gene_mutate_range = params.gene_mutate_range

  # Generate initial population
  population = []

  #placeholder for best solution

  best_solution = individual(prob)
  best_solution.cost = np.infty
  for i in range(number_in_population):
    new_individual = individual(prob)
    population.append(new_individual)

    if new_individual.cost < best_solution.cost:
      best_solution = deepcopy(new_individual)

  #  Generational Iteration

  for _iteration in range(max_number_of_generations):

    # create children

    children = []

    while len(children) < number_of_children_per_generation:
      parent1_index , parent2_index = choose_indices_from(len(population))
      parent1 = population[parent1_index]
      parent2 = population[parent2_index]

      child1, child2 = parent1.crossover(parent2,explore_crossover)
      child1.mutate(gene_mutate_rate, gene_mutate_range)
      child1.cost = cost_function(child1.chromosome)
      child2.mutate(gene_mutate_rate, gene_mutate_range)
      child2.cost = cost_function(child2.chromosome)

      # add children in list
      children.append(child1)
      children.append(child2)
      #end of the while loop

    # all children created

    # add the children to the population

    # sort the population

    # adjust the best solution






  return best_solution

bs = run_genetic(p1,par1)

