# -*- coding: utf-8 -*-
"""SearchTreeConnect4_24.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SkDKS7MkiE4KqFUvMZa4ITVoi1W-LVNy
"""

class CurrentBoard:
  # Connect 4
  # 6 rows
  # 7 columns

  board =["      " ,"      ","      " ,"      ","      " ,"      ","      "]
  def __init__(self,string_def = ["      ","      ","      " ,"      ","      " ,"      ","      "]) :
      self.board = string_def
      self.state = self.state_of_board()

  def display(self, game_display = False):
    for row in  range(len(self.board[0])):
      for col in range(len(self.board)):
          print(self.board[col][row],end = '')
      print()


    for i in range(len(self.board)):
      print(str(i),end='')

  def put_piece_in_column(self, piece , col_as_a_string):
    for i in range(len(col_as_a_string)-1):
      if (col_as_a_string[i] == " ") and (col_as_a_string[i+1] != " "):
        return col_as_a_string[:i] + piece + col_as_a_string[i+1:]
    return col_as_a_string[:-1] + piece

  def other(self,piece):
    if piece == "X":
      return "O"
    return "X"



  def state_of_board(self):
    return "U"


  def all_possible_moves(self, player_piece):
    possible_moves = []
    for index in range(len(self.board)):
      if self.board[index][0] == " ":
        new_column = self.put_piece_in_column(player_piece,self.board[index] )
        possible_moves.append(CurrentBoard(self.board[:index] + [new_column] + self.board[index+1:] ))


    return possible_moves

c4b = CurrentBoard()

class SearchTreeNode:

  def __init__(self,board_instance,playing_as, ply=0):
    self.children = []
    self.max_ply_depth = 4
    self.value_is_assigned = False
    self.ply_depth = ply
    self.current_board = board_instance
    self.move_for = playing_as
    if self.current_board.state == "U":
      if self.ply_depth<= self.max_ply_depth:
         self.generate_children()
      else:
        # evaluation function code
        r =1

    else:   # Game over
      if self.current_board.state == "D":
        self.value = 0
      else:
        if ((self.ply_depth % 2) == 0):
          self.value = -1000
        else:
          self.value = 1000
      self.value_is_assigned = True

  def min_max_value(self):
    if self.value_is_assigned:
      return self.value

    self.children  = sorted(self.children, key = lambda x:x.min_max_value())

    if ((self.ply_depth % 2) == 0):
      # computers move
      self.value = self.children[-1].value
    else:
      #players move
      self.value = self.children[0].value
    self.value_is_assigned = True

    return self.value

  def generate_children(self):
    for board_for_next_move in self.current_board.all_possible_moves(self.move_for):
      self.children.append(SearchTreeNode(board_for_next_move,self.current_board.other(self.move_for), ply = self.ply_depth +1))

st = SearchTreeNode(c4b,"X")

st.children[4].children[3].children[4].children[3].current_board.display()

